%==========================================
% Variable Declaration
%==========================================

clear;clc;

% Array of disease names for reference during plotting
diseases = {'Influenza', 'COVID-19', 'Measles'};

% Parameters for each disease: [Beta, Gamma]
% Beta: transmission rate, Gamma: recovery rate
parameters = [0.3, 0.1;  % Influenza
              1.0, 0.1;  % COVID-19
              2.0, 0.2]; % Measles

% Initial conditions for the population
totalPopulation = 1000; % Total number of people in the population
S0 = 990; % Initial number of susceptible individuals
I0 = 10;  % Initial number of infected individuals
R0 = 0;   % Initial number of recovered individuals

% Simulation time parameters
startDay = 0;    % Start of the simulation (day 0)
endDay = 100;    % End of the simulation (day 100)
step = 1;        % Time step size (1 day)

% Time vector representing each simulation step
time = startDay:step:endDay;

%==========================================
% Main Loop for Each Disease
%==========================================

for i = 1:3 % Loop through the three diseases
    % Extract the parameters Beta (transmission rate) and Gamma (recovery rate)
    Beta = parameters(i, 1);
    Gamma = parameters(i, 2);

    % Initialize the state variables for SIR
    Sx = S0; % Susceptible population
    Ix = I0; % Infected population
    Rx = R0; % Recovered population

    % Create arrays to store the S, I, and R values over time
    S_vals = zeros(1, length(time)); % Susceptible
    I_vals = zeros(1, length(time)); % Infected
    R_vals = zeros(1, length(time)); % Recovered

    % Assign initial conditions to the first element of the arrays
    S_vals(1) = Sx;
    I_vals(1) = Ix;
    R_vals(1) = Rx;

    %--------------------------------------------
    % Numerical Simulation Using RK4
    %--------------------------------------------
    for t = 2:length(time) % Loop over time steps (from the second step onwards)
        % Calculate RK4 updates for S, I, and R
        [k1_S, k1_I, k1_R] = sir_derivatives(Sx, Ix, Rx, Beta, Gamma, totalPopulation);
        [k2_S, k2_I, k2_R] = sir_derivatives(Sx + 0.5 * step * k1_S, ...
                                             Ix + 0.5 * step * k1_I, ...
                                             Rx + 0.5 * step * k1_R, ...
                                             Beta, Gamma, totalPopulation);
        [k3_S, k3_I, k3_R] = sir_derivatives(Sx + 0.5 * step * k2_S, ...
                                             Ix + 0.5 * step * k2_I, ...
                                             Rx + 0.5 * step * k2_R, ...
                                             Beta, Gamma, totalPopulation);
        [k4_S, k4_I, k4_R] = sir_derivatives(Sx + step * k3_S, ...
                                             Ix + step * k3_I, ...
                                             Rx + step * k3_R, ...
                                             Beta, Gamma, totalPopulation);

        % Update S, I, and R using the RK4 weighted average formula
        Sx = Sx + (step / 6) * (k1_S + 2 * k2_S + 2 * k3_S + k4_S);
        Ix = Ix + (step / 6) * (k1_I + 2 * k2_I + 2 * k3_I + k4_I);
        Rx = Rx + (step / 6) * (k1_R + 2 * k2_R + 2 * k3_R + k4_R);

        % Store the updated values into the arrays
        S_vals(t) = Sx;
        I_vals(t) = Ix;
        R_vals(t) = Rx;
    end

    %--------------------------------------------
    % Plot Results for Current Disease
    %--------------------------------------------
    figure; % Create a new figure for each disease
    plot(time, S_vals, 'b', 'LineWidth', 2); % Plot Susceptible population in blue
    hold on; % Allow multiple plots on the same figure
    plot(time, I_vals, 'r', 'LineWidth', 2); % Plot Infected population in red
    plot(time, R_vals, 'g', 'LineWidth', 2); % Plot Recovered population in green
    title(['Disease Progression: ', diseases{i}]); % Set title with disease name
    xlabel('Time (days)'); % Label x-axis
    ylabel('Population'); % Label y-axis
    legend('Susceptible', 'Infected', 'Recovered'); % Add legend
    grid on; % Enable grid for better visualization
end

%==========================================
% Function to Compute Derivatives
%==========================================

function [dS, dI, dR] = sir_derivatives(S, I, R, Beta, Gamma, N)
    % This function calculates the derivatives dS/dt, dI/dt, and dR/dt
    % Inputs:
    %   S - Susceptible population
    %   I - Infected population
    %   R - Recovered population
    %   Beta - Transmission rate
    %   Gamma - Recovery rate
    %   N - Total population (constant)

    dS = -Beta * S * I / N;      % Rate of change of susceptible population
    dI = Beta * S * I / N - Gamma * I; % Rate of change of infected population
    dR = Gamma * I;              % Rate of change of recovered population
end

%=======================================================================
% Part 1 - SIR Model with Interpolation and Error Calculation
%=======================================================================
clear; clc;

R_vals_odd = [...
    5.249645923425, ...
    113.795533092792, ...
    370.442750120656, ...
    574.504027395652, ...
    714.153914472430, ...
    808.197155721458, ...
    871.341681966335, ...
    913.704893921184, ...
    942.117380649110, ...
    961.170630374598, ...
    973.946704981386, ...
    982.513296173626, ...
    988.257211199448, ...
    992.108458071344, ...
    994.690661759106, ...
    996.421979999912, ...
    997.582791020635, ...
    998.361087308009, ...
    998.882915586853, ...
    999.232788032032, ...
    999.467368323313, ...
    999.624648167139, ...
    999.730100079829, ...
    999.800802739159, ...
    999.848206955014, ...
    999.901299988156, ...
    999.915587624776, ...
    999.925167095195, ...
    999.931589868531, ...
    999.935896162606, ...
    999.938783415124, ...
    999.940719239037, ...
    999.942017156065, ...
    999.942887373957, ...
    999.943470831267, ...
    999.943862023446, ...
    999.944124307108, ...
    999.944300161134, ...
    999.944418066452, ...
    999.944497118744, ...
    999.944526259773, ...
    999.944585657806, ...
    999.944609484166, ...
    999.944625459089, ...
    999.944636169838, ...
    999.944643351102, ...
    999.944648165944, ...
    999.944651394163, ...
    999.944653558596, ...
    999.944654356471];


S_vals_odd = [...
    939.455396202409, ...
    319.872155220907, ...
    28.4372728359424, ...
    3.87573713008482, ...
    0.963908355659512, ...
    0.376538534141428, ...
    0.200254807848235, ...
    0.131098002119168, ...
    0.0986730916131624, ...
    0.0815548706962492, ...
    0.0717733793954508, ...
    0.0658807967762818, ...
    0.0622032670301176, ...
    0.0598532006755350, ...
    0.0583274490672938, ...
    0.0573263051221622, ...
    0.0566647017234276, ...
    0.0562253938993891, ...
    0.0559327579395399, ...
    0.0557374065055305, ...
    0.0556068107413495, ...
    0.0555194211641397, ...
    0.0554609057249176, ...
    0.0554217072458319, ...
    0.0553954412449881, ...
    0.0553778375772537, ...
    0.0553660379304755, ...
    0.0553581279971408, ...
    0.0553528252355882, ...
    0.0553492701632351, ...
    0.0553468867122028, ...
    0.0553452887308872, ...
    0.0553442173539212, ...
    0.0553434990365612, ...
    0.0553430174296256, ...
    0.0553426945276863, ...
    0.0553424780318174, ...
    0.0553423328777294, ...
    0.0553422355560945, ...
    0.0553421703046945, ...
    0.0553421265554575, ...
    0.0553420972228094, ...
    0.0553420775560794, ...
    0.0553420643700785, ...
    0.0553420555292271, ...
    0.0553420496016787, ...
    0.0553420456274199, ...
    0.0553420429627881, ...
    0.0553420411762255, ...
    0.0553420399783841];

I_vals_odd = [...
    55.2949578741670, ...
    566.332311686302, ...
    601.119977043402, ...
    421.620235474263, ...
    284.882177171910, ...
    191.426305744401, ...
    128.458063225817, ...
    86.1640080766970, ...
    57.7839462592775, ...
    38.7478147547056, ...
    25.9815216392193, ...
    17.4208230295976, ...
    11.6805855335224, ...
    7.83168872798110, ...
    5.25101079182723, ...
    3.52069369496598, ...
    2.36054427764203, ...
    1.58268729809174, ...
    1.06115165520790, ...
    0.711474561462934, ...
    0.477024865946508, ...
    0.319832411697396, ...
    0.214439014446688, ...
    0.143775553596012, ...
    0.0963976037410371, ...
    0.0646319695530795, ...
    0.0433339739142272, ...
    0.0290542472268762, ...
    0.0194800795694197, ...
    0.0130608613065735, ...
    0.00875695068196972, ...
    0.00641282656234962, ...
    0.00480755793975918, ...
    0.00393654360934814, ...
    0.00322333620705734, ...
    0.00263934489932135, ...
    0.00216115882613742, ...
    0.00176960861414926, ...
    0.00144899792100770, ...
    0.000971513498666598, ...
    0.000795498522902435, ...
    0.000651373244629849, ...
    0.000533360014560677, ...
    0.000436727955045383, ...
    0.000357603310133263, ...
    0.000292814155656287, ...
    0.000239763244124270, ...
    0.000196323887078098, ...
    0.000160754701065841, ...
    0.000131629799605410];

%==========================================
% Constants and Initialization
%==========================================
% Disease parameters [Beta, Gamma] for Influenza
parameters = [0.3, 0.1];

% Initial conditions
totalPopulation = 1000; % Total population
S0 = 990; % Initial susceptible population
I0 = 10;  % Initial infected population
R0 = 0;   % Initial recovered population

% Time settings
startDay = 0;
endDay = 100;
coarseStep = 2; % Time step for interpolation analysis
fineStep = 1;   % Finer time step for model truth
time_coarse = startDay:coarseStep:endDay;
time_fine = startDay:fineStep:endDay;
time_int = startDay+1:coarseStep:endDay-1;

% Observed odd-day values (model output)
%S_vals_odd = [...]; % Fill from provided data
%I_vals_odd = [...]; % Fill from provided data
%R_vals_odd = [...]; % Fill from provided data

% Preallocate arrays for storing results
S_vals_coarse = zeros(1, length(time_coarse));
I_vals_coarse = zeros(1, length(time_coarse));
R_vals_coarse = zeros(1, length(time_coarse));

% Storage for interpolated values
S_vals_int = zeros(1, length(time_int));
I_vals_int = zeros(1, length(time_int));
R_vals_int = zeros(1, length(time_int));

S_vals_quad = zeros(1, length(time_int));
I_vals_quad = zeros(1, length(time_int));
R_vals_quad = zeros(1, length(time_int));

%==========================================
% Numerical Simulation Using RK4
%==========================================
% Extract parameters
Beta = parameters(1);
Gamma = parameters(2);

% Initial conditions for coarse model
Sx = S0; Ix = I0; Rx = R0;

% Assign initial conditions
S_vals_coarse(1) = Sx;
I_vals_coarse(1) = Ix;
R_vals_coarse(1) = Rx;

for t = 2:length(time_coarse)
    % RK4 updates for SIR model
    [k1_S, k1_I, k1_R] = sir_derivatives(Sx, Ix, Rx, Beta, Gamma, totalPopulation);
    [k2_S, k2_I, k2_R] = sir_derivatives(Sx + 0.5 * coarseStep * k1_S, ...
                                         Ix + 0.5 * coarseStep * k1_I, ...
                                         Rx + 0.5 * coarseStep * k1_R, ...
                                         Beta, Gamma, totalPopulation);
    [k3_S, k3_I, k3_R] = sir_derivatives(Sx + 0.5 * coarseStep * k2_S, ...
                                         Ix + 0.5 * coarseStep * k2_I, ...
                                         Rx + 0.5 * coarseStep * k2_R, ...
                                         Beta, Gamma, totalPopulation);
    [k4_S, k4_I, k4_R] = sir_derivatives(Sx + coarseStep * k3_S, ...
                                         Ix + coarseStep * k3_I, ...
                                         Rx + coarseStep * k3_R, ...
                                         Beta, Gamma, totalPopulation);

    % Update states
    Sx = Sx + (coarseStep / 6) * (k1_S + 2 * k2_S + 2 * k3_S + k4_S);
    Ix = Ix + (coarseStep / 6) * (k1_I + 2 * k2_I + 2 * k3_I + k4_I);
    Rx = Rx + (coarseStep / 6) * (k1_R + 2 * k2_R + 2 * k3_R + k4_R);

    % Store updated values
    S_vals_coarse(t) = Sx;
    I_vals_coarse(t) = Ix;
    R_vals_coarse(t) = Rx;
end

%==========================================
% Interpolation
%==========================================
for t = 2:length(time_coarse)-1
    X0 = time_coarse(t - 1);
    X1 = time_coarse(t + 1);
    X = time_coarse(t);

    % Linear interpolation
    S_vals_int(t - 1) = (X1 - X) / (X1 - X0) * S_vals_coarse(t - 1) + ...
                        (X - X0) / (X1 - X0) * S_vals_coarse(t + 1);
    I_vals_int(t - 1) = (X1 - X) / (X1 - X0) * I_vals_coarse(t - 1) + ...
                        (X - X0) / (X1 - X0) * I_vals_coarse(t + 1);
    R_vals_int(t - 1) = (X1 - X) / (X1 - X0) * R_vals_coarse(t - 1) + ...
                        (X - X0) / (X1 - X0) * R_vals_coarse(t + 1);

    % Quadratic interpolation
    if t > 2 && t < length(time_coarse)-1
        X2 = time_coarse(t + 2);
        S_vals_quad(t - 1) = ((X - X1) * (X - X2)) / ((X0 - X1) * (X0 - X2)) * S_vals_coarse(t - 2) + ...
                             ((X - X0) * (X - X2)) / ((X1 - X0) * (X1 - X2)) * S_vals_coarse(t - 1) + ...
                             ((X - X0) * (X - X1)) / ((X2 - X0) * (X2 - X1)) * S_vals_coarse(t + 1);
        I_vals_quad(t - 1) = ((X - X1) * (X - X2)) / ((X0 - X1) * (X0 - X2)) * I_vals_coarse(t - 2) + ...
                             ((X - X0) * (X - X2)) / ((X1 - X0) * (X1 - X2)) * I_vals_coarse(t - 1) + ...
                             ((X - X0) * (X - X1)) / ((X2 - X0) * (X2 - X1)) * I_vals_coarse(t + 1);
        R_vals_quad(t - 1) = ((X - X1) * (X - X2)) / ((X0 - X1) * (X0 - X2)) * R_vals_coarse(t - 2) + ...
                             ((X - X0) * (X - X2)) / ((X1 - X0) * (X1 - X2)) * R_vals_coarse(t - 1) + ...
                             ((X - X0) * (X - X1)) / ((X2 - X0) * (X2 - X1)) * R_vals_coarse(t + 1);
    end
end

%==========================================
% Error Calculation
%==========================================
linearError_S = sqrt(sum((S_vals_odd - S_vals_int).^2) / length(S_vals_int));
linearError_I = sqrt(sum((I_vals_odd - I_vals_int).^2) / length(I_vals_int));
linearError_R = sqrt(sum((R_vals_odd - R_vals_int).^2) / length(R_vals_int));

quadError_S = sqrt(sum((S_vals_odd - S_vals_quad).^2) / length(S_vals_quad));
quadError_I = sqrt(sum((I_vals_odd - I_vals_quad).^2) / length(I_vals_quad));
quadError_R = sqrt(sum((R_vals_odd - R_vals_quad).^2) / length(R_vals_quad));

% Display error table
errorTable = array2table([linearError_S, linearError_I, linearError_R; ...
                          quadError_S, quadError_I, quadError_R], ...
    'VariableNames', {'S(t)_Error', 'I(t)_Error', 'R(t)_Error'}, ...
    'RowNames', {'Linear', 'Quadratic'});
disp(errorTable);

%==========================================
% Functions
%==========================================
function [dS, dI, dR] = sir_derivatives(S, I, R, Beta, Gamma, N)
    dS = -Beta * S * I / N;
    dI = Beta * S * I / N - Gamma * I;
    dR = Gamma * I;
end

%Define Beta Function for transmission rate
T_r = .3.*(1+5.*sin(2.*pi.*(365/365).*time));
Beta(i) = .3;
Gamma = .1 ;
h = .1; %step size
t0 = 0;
tf = 30 ;
time = t0:h:tf;
%Population initial conditions
Total = 1000;
S0 = 990;
I0 = 10;
R = 0;
%Arrays
S_1 = zeros(1,length(time));
I_1= zeros(1,length(time));
R_1= zeros(1,length(time));
S_1(1)= S0;
I_1(1)= I0;
R_1(1)= R0;

for i = 2:length(time)
    [Sk1,Ik1, Rk1] = dSIRdt(Sx, Ix, Rx,Beta(i), Gamma, Total);
    [Sk2,Ik2, Rk2] = dSIRdt(Sx + (.5*Sk1*h),Ix + (.5*Ik1*h),Rx+(.5*Rk1*h),Beta(i), Gamma, Total);
    [Sk3,Ik3, Rk3] = dSIRdt(Sx + (.5*Sk2*h),Ix + (.5*Ik2*h),Rx+(.5*Rk2*h),Beta(i), Gamma, Total);
    [Sk4,Ik4, Rk4] = dSIRdt(Sx + (Sk3*h),Ix + (Ik3*h),Rx+(Rk3*h),Beta(i), Gamma, Total);
% Runge-Katta Formula
    Sx = Sx + ((h/6)*(Sk1+2*Sk2+2*Sk3+Sk4));
    Ix = Ix + ((h/6)*(Ik1+2*Ik2+2*Ik3+Ik4));
    Rx = Rx + ((h/6)*(Rk1+2*Rk2+2*Rk3+Rk4));
%Storing Values
    S_1(i) = Sx;
    I_1(i) = Ix;
    R_1(i) = Rx;
end


% PART 4: Fourier Analysis



% Creating plot for Beta Function

figure;
plot (time, S_1, 'r', time, I_1,'g',R_1,'b')
legend('Susceptible','Infected','Recovered')
xlabel('Time')
ylabel('Respective Populations')
title('Variable Spread Rate Omega = 2pi*365/365')
grid on
%Discussion
%Periodic fluctuation of function visible(high frequency)

% Define frequency range
t = 30;
N=length(time);
f = (1/t)*(0:(N/2));
% Calculate spectrum
spectrum=fft(I);
P2 = abs(spectrum/N);
P1 = P2(1:N/2+1);
P1(2:end-1) = 2*P1(2:end-1);
plot(f,P1);
title("Spectrum of Infected Cases, Omega = 2pi*365/365");
xlabel("frequency Coefficient")
ylabel("Absolute Value fft(I(t))")

%Discussion

clearvars;

%Part Two, omega = 2pi*100/365

%Define Beta Function for transmission rate
T_r = .3.*(1+5.*sin(2.*pi.*(100/365).*time));
Beta(i) = .3;
Gamma = .1 ;
h = .1; %step size
t0 = 0;
tf = 30 ;
time = t0:h:tf;
%Population initial conditions
Total = 1000;
S0 = 990;
I0 = 10;
R = 0;
%Arrays
S_1 = zeros(1,length(time));
I_1= zeros(1,length(time));
R_1= zeros(1,length(time));
S_1(1)= S0;
I_1(1)= I0;
R_1(1)= R0;

for i = 2:length(time)
    [Sk1,Ik1, Rk1] = dSIRdt(Sx, Ix, Rx,Beta(i), Gamma, Total);
    [Sk2,Ik2, Rk2] = dSIRdt(Sx + (.5*Sk1*h),Ix + (.5*Ik1*h),Rx+(.5*Rk1*h),Beta(i), Gamma, Total);
    [Sk3,Ik3, Rk3] = dSIRdt(Sx + (.5*Sk2*h),Ix + (.5*Ik2*h),Rx+(.5*Rk2*h),Beta(i), Gamma, Total);
    [Sk4,Ik4, Rk4] = dSIRdt(Sx + (Sk3*h),Ix + (Ik3*h),Rx+(Rk3*h),Beta(i), Gamma, Total);
% Runge-Katta Formula
    Sx = Sx + ((h/6)*(Sk1+2*Sk2+2*Sk3+Sk4));
    Ix = Ix + ((h/6)*(Ik1+2*Ik2+2*Ik3+Ik4));
    Rx = Rx + ((h/6)*(Rk1+2*Rk2+2*Rk3+Rk4));
%Storing Values
    S_1(i) = Sx;
    I_1(i) = Ix;
    R_1(i) = Rx;
end

% Creating plot for Beta Function

figure;
plot (time, S_1, 'r', time, I_1,'g',R_1,'b')
legend('Susceptible','Infected','Recovered')
xlabel('Time')
ylabel('Respective Populations')
title('Variable Spread Rate Omega = 2pi*365/365')
grid on
%Discussion
%Periodic fluctuation of function visible(high frequency)

% Define frequency range
t = 30;
N=length(time);
f = (1/t)*(0:(N/2));
% Calculate spectrum
spectrum=fft(I);
P2 = abs(spectrum/N);
P1 = P2(1:N/2+1);
P1(2:end-1) = 2*P1(2:end-1);
plot(f,P1);
title("Spectrum of Infected Cases, Omega = 2pi*100/365");
xlabel("frequency Coefficient")
ylabel("Absolute Value fft(I(t))")
